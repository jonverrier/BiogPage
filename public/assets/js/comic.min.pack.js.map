{"version":3,"file":"comic.min.pack.js","mappings":"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","sources":["./comic.js"],"sourcesContent":["/**\r\n * @brief Comic style version of common drawing functions.\r\n *\r\n * Comic style version of common drawing functions, that is\r\n * implemented as library agnostic JS extension. Only assuming\r\n * that given \"lib\" can be extended the JS way (setting properties)\r\n * and that if a \"path\" method is given, it is a drawing method\r\n * which understands standard SVG path format strings.\r\n * If no \"path\" is given, it will check if \"lib\" is a 2d canvas context\r\n * and use context drawing functions. If \"lib\" is not a 2d canvas\r\n * context, as last guess it will try to call an SVG \"path\" method\r\n * directly on the \"lib\" object.\r\n *\r\n * Credits:\r\n * Inspired by and based on Jonas Wagner's work\r\n * http://29a.ch/2010/2/10/hand-drawn-lines-algorithm-javascript-canvas-html5\r\n * which is based on this paper\r\n * http://iwi.eldoc.ub.rug.nl/FILES/root/2008/ProcCAGVIMeraj/2008ProcCAGVIMeraj.pdf\r\n *\r\n * @author Balint Morvai <balint@morvai.de>\r\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n */\r\n// global object\r\nCOMIC = { version: 0.96 };\r\n\r\n(function () {\r\n\r\n   https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\r\n\r\n   function mulberry32(a) {\r\n      return function () {\r\n         var t = a += 0x6D2B79F5;\r\n         t = Math.imul(t ^ t >>> 15, t | 1);\r\n         t ^= t + Math.imul(t ^ t >>> 7, t | 61);\r\n         return ((t ^ t >>> 14) >>> 0) / 4294967296;\r\n      }\r\n   }\r\n\r\n   var rand = mulberry32(0);\r\n\r\n   function reseed(x1, y1, x2, y2) {\r\n      // we re-seed based on x-y coords to give consistent values when a line starts or ends at the same point. \r\n      hash1 = (y1 << 16) ^ x1;\r\n      hash2 = (y2 << 16) ^ x2;\r\n\r\n      rand = mulberry32(hash1 + hash2);\r\n   }\r\n\r\n\r\n\r\n/**\r\n * @var object global \"C\" object\r\n */\r\nvar C = COMIC;\r\n/**\r\n * @var int length of one step - each step means new \"hand jitter\"\r\n */\r\nvar fsteps = 5;\r\n/**\r\n * @var int min number of steps\r\n */\r\nvar msteps = 3;\r\n/**\r\n * @var float fuzzyness factor\r\n */\r\nvar ff = 8.0;\r\n/**\r\n * @var float fuzzyness factor for circle & ellipse\r\n */\r\nvar ffc = 5.0;\r\n/**\r\n * @var float drunk style fuzzyness - everything has stronger curvature\r\n */\r\nvar drunk = false;\r\n/**\r\n * @var object 2d canvas context (if any)\r\n */\r\nvar context = undefined;\r\n/**\r\n * @var function code to execute when starting drawing a shape\r\n */\r\nvar begin = function() {};\r\n/**\r\n * @var function code to execute when finished drawing a shape\r\n */\r\nvar finish = function() {};\r\n/**\r\n * @var function code to draw comic path using specific user lib\r\n */\r\nvar path = function() {};\r\n/**\r\n * @var string path string built upon subsequent calls of \"path\" function\r\n */\r\nvar pathStr = \"\";\r\n/**\r\n * @var int decimal precision to which all drawing coordinates will be rounded\r\n */\r\nvar precision = 10;\r\n/**\r\n * @var int factor used by local \"round\" function, auto calculated from precision\r\n */\r\nvar roundFactor = Math.pow(10, precision);\r\n/**\r\n * @var point current drawing point of path - needed for continuous paths\r\n */\r\nC.pathPos = { x:0, y:0 };\r\n\r\n/**\r\n * Public function to allow user defined options, also\r\n * setting a 2d canvas context for drawing.\r\n *\r\n * @param options object with options\r\n * @return C object\r\n */\r\nC.init = function(options) {\r\n    // no need to deep copy & no need to drop unknown options\r\n    for(var prop in options) {\r\n        if(options.hasOwnProperty(prop)) {\r\n            C[prop] = options[prop];\r\n            // hard coded fudge factor\r\n            if(prop == 'fsteps')\r\n                C.fsteps *= 10;\r\n        }\r\n    }\r\n\r\n    // if new canvas context call bind to\r\n    if(typeof options[\"context\"] == \"object\") {\r\n        bindTo(\"canvas\", C.context);\r\n    }\r\n\r\n    return C;\r\n}\r\n\r\n/**\r\n * Public function to init drawing functions on the given\r\n * 2d canvas context.\r\n *\r\n * @param context 2d canvas context\r\n * @return C object\r\n */\r\nC.ctx = function(context) {\r\n    C.init({ \"context\": context });\r\n\r\n    return C;\r\n}\r\n\r\n/**\r\n * Binds comic drawing functions to the given library using the\r\n * given method to draw svg paths. If no method is given (2nd param),\r\n * it tries to call \"path\" directly on lib.\r\n *\r\n * @param libName root object to hook in to\r\n * @param lib root object to hook in to\r\n * @return void\r\n */\r\nvar bindTo = function(libName, lib) {\r\n    /**\r\n     * WRAPPER for real, private \"cBezier3\"\r\n     * hand draw a cubic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx0 x 1st control point\r\n     * @param cy0 y 1st control point\r\n     * @param cx1 x 2nd control point\r\n     * @param cy1 y 2nd control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    lib.cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\r\n        begin.call(this);\r\n        cBezier3.call(this, x0, y0, cx0, cy0, cx1, cy1, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cBezier3\" public.\r\n     * hand draw a cubic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx0 x 1st control point\r\n     * @param cy0 y 1st control point\r\n     * @param cx1 x 2nd control point\r\n     * @param cy1 y 2nd control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    var cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\r\n        // number of steps - this is a very primitive approach to\r\n        // estimate the Bezier arc length\r\n        var d = dist2(x0, y0, x1, y1) * 3;\r\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\r\n        // fuzzyness\r\n        var f = C.ff * 0.8;\r\n\r\n        var p0 = [x0, y0];\r\n        var pc0 = [cx0, cy0];\r\n        var pc1 = [cx1, cy1];\r\n        var p1 = [x1, y1];\r\n        var curve2 = [p0, pc0, pc1, p1];\r\n        for(var i = steps; i > 0; i--) {\r\n            // split curve2\r\n            var points = bsplit(curve2, 1/i);\r\n            var curve1 = points[0];\r\n            var curve2 = points[1];\r\n            // set points for drawing from curve1\r\n            p0 = curve1[0]; pc0 = curve1[1];  pc1 = curve1[2]; p1 = curve1[3];\r\n\r\n            path.call(this, p0[0], p0[1],\r\n                fuzz((pc0[0]+pc1[0])/2, f), // just make one control point\r\n                fuzz((pc0[1]+pc1[1])/2, f),\r\n                p1[0], p1[1]);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cBezier2\"\r\n     * hand draw a quadratic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx x control point\r\n     * @param cy y control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    lib.cBezier2 = function(x0, y0, cx, cy, x1, y1) {\r\n        begin.call(this);\r\n        cBezier2.call(this, x0, y0, cx, cy, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cBezier2\" public.\r\n     * hand draw a quadratic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx x control point\r\n     * @param cy y control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    var cBezier2 = function(x0, y0, cx, cy, x1, y1) {\r\n        // number of steps - this is a very primitive approach to\r\n        // estimate the Bezier arc length\r\n        var d = dist2(x0, y0, x1, y1) * 3;\r\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\r\n        // fuzzyness\r\n        var f = C.ff * 0.8;\r\n\r\n        var p0 = [x0, y0];\r\n        var pc = [cx, cy];\r\n        var p1 = [x1, y1];\r\n        var curve2 = [p0, pc, p1];\r\n        for(var i = steps; i > 0; i--) {\r\n            // split curve2\r\n            var points = bsplit(curve2, 1/i);\r\n            var curve1 = points[0];\r\n            var curve2 = points[1];\r\n            // set points for drawing from curve1\r\n            p0 = curve1[0]; pc = curve1[1]; p1 = curve1[2];\r\n\r\n            path.call(this, p0[0], p0[1], fuzz(pc[0], f), fuzz(pc[1], f), p1[0], p1[1]);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cEllipse\"\r\n     * Draw a comic style / hand drawn cEllipse\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in radians\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    lib.cEllipse = function(x, y, rh, rv, rot, start, end) {\r\n        begin.call(this);\r\n        cEllipse.call(this, x, y, rh, rv, rot, start, end);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cEllipse\" public.\r\n     * hand draw an ellipse\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in radians\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    var cEllipse = function(x, y, rh, rv, rot, start, end) {\r\n        var PI2 = Math.PI * 2;\r\n        // sanitize input\r\n        start = (typeof start == \"undefined\") ? 0 : start;\r\n        end = (typeof end == \"undefined\") ? PI2 : end;\r\n        rot = (typeof rot == \"undefined\") ? 0 : rot;\r\n        // rotation\r\n        var cosRot = Math.cos(rot);\r\n        var sinRot = Math.sin(rot);\r\n        // number of steps\r\n        var steps = C.msteps + ((rh + rv) / 2) * C.fsteps / 200;\r\n        // fuzzyness dependent on on radius\r\n        var fh = C.ffc * Math.pow(rh, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        var fv = C.ffc * Math.pow(rv, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        // distortion of the ellipse\r\n        var xs = 0.95 + rand() * 0.1;\r\n       var ys = 0.95 + rand() * 0.1;\r\n        var rxs = rh * xs;\r\n        var rys = rv * ys;\r\n        // lenght of one segment\r\n        var arcLength = end - start;\r\n        var segLength = arcLength / steps;\r\n\r\n        // initial values for i = 0\r\n        var t1 = start; var t0, x0, y0;\r\n        var cosT1rxs = rxs * Math.cos(t1);\r\n        var sinT1rys = rys * Math.sin(t1);\r\n        var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\r\n        var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\r\n\r\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x + rh * Math.cos(t1) * cosRot - rv * Math.sin(t1) * sinRot, // would be start x\r\n                   y + rh * Math.cos(t1) * sinRot + rv * Math.sin(t1) * cosRot, // would be start y\r\n                   x1,  // actual start x\r\n                   y1); // actual start y\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = t1 + segLength;\r\n            var x0 = x1;\r\n            var y0 = y1;\r\n            var cosT1rxs = rxs * Math.cos(t1);\r\n            var sinT1rys = rys * Math.sin(t1);\r\n            var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\r\n            var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\r\n\r\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, fh), fuzz((y0 + y1) / 2, fv), x1, y1);\r\n        }\r\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x1, // actual end x\r\n                   y1, // actual end y\r\n                   x + rh * Math.cos(end) * cosRot - rv * Math.sin(end) * sinRot,  // would be end x\r\n                   y + rh * Math.cos(end) * sinRot + rv * Math.sin(end) * cosRot); // would be end y\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cCircle\"\r\n     * Draw a comic style / hand drawn circle\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param r radius\r\n     * @param start start in radians (< 2*PI) for drawing an arc only (optional)\r\n     * @param end end in radians (< 2*PI) for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    lib.cCircle = function(x, y, r, start, end) {\r\n        begin.call(this);\r\n        cCircle.call(this, x, y, r, start, end);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cCircle\" public.\r\n     * hand draw a circle\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param r radius\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    var cCircle = function(x, y, r, start, end) {\r\n        var PI2 = Math.PI * 2;\r\n        // sanitize input\r\n        start = (typeof start == \"undefined\") ? 0 : start;\r\n        end = (typeof end == \"undefined\") ? PI2 : end;\r\n        // number of steps\r\n        var steps = C.msteps + r * C.fsteps / 200;\r\n        // fuzzyness dependent on on radius\r\n        var f = C.ffc * Math.pow(r, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        // distortion of the circle\r\n        var xs = 0.975 + rand() * 0.05;\r\n        var rxs = r * xs;\r\n        var rys = r * (2.0 - xs);\r\n        // lenght of one segment\r\n        var arcLength = end - start;\r\n        var segLength = arcLength / steps;\r\n\r\n        // initial values for i = 0\r\n        var t1 = start; var t0, x0, y0;\r\n        var x1 = x + Math.cos(t1) * rxs;\r\n        var y1 = y + Math.sin(t1) * rys; // initial values for i = 0\r\n\r\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x + Math.cos(t1) * r, // would be start x\r\n                   y + Math.sin(t1) * r, // would be start y\r\n                   x1,  // actual start x\r\n                   y1); // actual start y\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = t1 + segLength;\r\n            x0 = x1;\r\n            y0 = y1;\r\n            x1 = x + Math.cos(t1) * rxs;\r\n            y1 = y + Math.sin(t1) * rys;\r\n\r\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, f), fuzz((y0 + y1) / 2, f), x1, y1);\r\n        }\r\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x1, // actual end x\r\n                   y1, // actual end y\r\n                   x + Math.cos(end) * r,  // would be end x\r\n                   y + Math.sin(end) * r); // would be end y\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Draw a triangle using line function\r\n     *\r\n     * @param x0 x first point\r\n     * @param y0 y first point\r\n     * @param x1 x second point\r\n     * @param y1 y second point\r\n     * @param x2 x third point\r\n     * @param y2 y third point\r\n     * @return native library object\r\n     */\r\n    lib.cTrian = function(x0, y0, x1, y1, x2, y2) {\r\n        begin.call(this);\r\n        cLine.call(this, x0, y0, x1, y1);\r\n        cLine.call(this, x1, y1, x2, y2);\r\n        cLine.call(this, x2, y2, x0, y0);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cRect\"\r\n     * Draw a comic style / hand drawn rectangle using line function\r\n     *\r\n     * @param x0 x upper left corcer\r\n     * @param y0 y upper left corner\r\n     * @param width width of the rectangle\r\n     * @param height height of the rectangle\r\n     * @param rh horizontal radius of rounded corners\r\n     * @param rv vertical radius of rounded corners\r\n     * @return native library object\r\n     */\r\n    lib.cRect = function(x0, y0, width, height, rh, rv) {\r\n        begin.call(this);\r\n        cRect.call(this, x0, y0, width, height, rh, rv);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cRect\" public.\r\n     * Draw a comic style / hand drawn rectangle using line function\r\n     *\r\n     * @param x0 x upper left corcer\r\n     * @param y0 y upper left corner\r\n     * @param width width of the rectangle\r\n     * @param height height of the rectangle\r\n     * @param rh horizontal radius of rounded corners\r\n     * @param rv vertical radius of rounded corners\r\n     * @return native library object\r\n     */\r\n    var cRect = function(x0, y0, width, height, rh, rv) {\r\n        var halfPI;\r\n        // sanitize input\r\n        rh = (typeof rh == \"undefined\") ? 0 : Math.min(rh, width/2);\r\n        rv = (typeof rv == \"undefined\") ? rh : Math.min(rv, height/2);\r\n        // calculate lower left corner\r\n        var x1 = x0 + width;\r\n        var y1 = y0 + height;\r\n\r\n        cLine.call(this, x0+rh, y0, x1-rh, y0);\r\n        if(rh > 0) {\r\n            halfPI = Math.PI / 2;\r\n            cEllipse.call(this, x1-rh, y0+rv, rh, rv, 0, halfPI*3, Math.PI*2);\r\n        }\r\n        cLine.call(this, x1, y0+rv, x1, y1-rv);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x1-rh, y1-rv, rh, rv, 0, 0, halfPI);\r\n        }\r\n        cLine.call(this, x1-rh, y1, x0+rh, y1);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x0+rh, y1-rv, rh, rv, 0, halfPI, Math.PI);\r\n        }\r\n        cLine.call(this, x0, y1-rv, x0, y0+rv);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x0+rh, y0+rv, rh, rv, 0, Math.PI, halfPI*3);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cLine\"\r\n     * Draw a comic style / hand drawn line\r\n     *\r\n     * @param x0 x start\r\n     * @param y0 y start\r\n     * @param x1 x end\r\n     * @param y1 y end\r\n     * @return native library object\r\n     */\r\n    lib.cLine = function(x0, y0, x1, y1) {\r\n        begin.call(this);\r\n        cLine.call(this, x0, y0, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cLine\" public.\r\n     * Draw a comic style / hand drawn line\r\n     *\r\n     * @param x0 x start\r\n     * @param y0 y start\r\n     * @param x1 x end\r\n     * @param y1 y end\r\n     * @return native library object\r\n     */\r\n   var cLine = function (x0, y0, x1, y1) {\r\n\r\n      reseed(x0, y0);\r\n\r\n        /**\r\n         * Estimate the movement of the arm\r\n         * Reuses 3rd param from last call if omitted\r\n         *\r\n         * @param x0 x start\r\n         * @param x1 x end\r\n         * @param t step from 0 to 1\r\n         * @return number\r\n         */\r\n        var ft; // store this outside function to preserve\r\n        var handMovement = function(x0, x1, t) {\r\n            // calculate ft or use old value if no \"t\" given\r\n            if(typeof t != \"undefined\") {\r\n                var pow3 = Math.pow(t, 3);\r\n                var pow4 = pow3 * t;\r\n                var pow5 = pow4 * t;\r\n                ft = (15 * pow4 -\r\n                      6 * pow5 -\r\n                      10 * pow3);\r\n            }\r\n\r\n            return x0 + (x0 - x1) * ft;\r\n        }\r\n\r\n        // calculate number of steps\r\n        var d = dist2(x0, y0, x1, y1);\r\n        var steps = Math.ceil(d / C.fsteps);\r\n        if(steps < C.msteps) {\r\n            steps = C.msteps;\r\n        }\r\n        // fuzz factor\r\n        f = C.ff / ((steps == C.msteps) ? 1.4 : 1); // reduce for small lines\r\n        // draw line step by step using quadratic BÃ©zier path\r\n        var xt1 = handMovement(x0, x1, 0); // bezier control point\r\n        var yt1 = handMovement(y0, y1); // bezier control point (reuse t0)\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = i / steps;\r\n            var xt0 = xt1; // bezier control point\r\n            var yt0 = yt1; // bezier control point\r\n            var xt1 = handMovement(x0, x1, t1); // bezier end point\r\n            var yt1 = handMovement(y0, y1); // bezier end point (reuse t1)\r\n\r\n            path.call(this, xt0, yt0, fuzz((xt0 + xt1) / 2, f), fuzz((yt0 + yt1) / 2, f), xt1, yt1);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Smart function for digesting input given to \"magic\" function.\r\n     * It looks for valid drawing elements, svg & g, and tries to find\r\n     * them in SVGDocument, Node and in direct children and parent\r\n     * elements.\r\n     *\r\n     * @param e Node or Element\r\n     * @return element\r\n     */\r\n    var unWrap = function(e) {\r\n        var msg = \"error: no drawing element given\"; // in case of error\r\n        found = false; // false until valid drawing object found\r\n        tags = [\"svg\", \"g\"] // array of valid drawing tags\r\n        var unArray = function(e) {\r\n            // \"string\" of course is nonsense but would cause infinite loop\r\n            while(e[0] && typeof e[0] != \"string\") {\r\n                e = e[0];\r\n            }\r\n            return e;\r\n        }\r\n        // unwrap from e.g. SVGDocument\r\n        var unCD = function(e) {\r\n            if(e.contentDocument) e = e.contentDocument;\r\n            return e;\r\n        }\r\n        // look in the \"node\"\r\n        var unNode = function(e) {\r\n            if(typeof e.node == \"object\") {\r\n                if(typeof e.node.tagName == \"string\")\r\n                    e = e.node;\r\n            }\r\n            return e;\r\n        }\r\n        var checkTag = function(e) {\r\n            return (typeof e.tagName != \"string\") ?\r\n                    false : tags.indexOf(e.tagName) >= 0;\r\n        }\r\n        e = unArray(e);\r\n        e = unCD(e);\r\n        e = unNode(e);\r\n        // looking for an element, not any node, thus with \"tagName\"\r\n        if(! (found = checkTag(e)) ) {\r\n            // look in direct \"child\" elements\r\n            if(typeof e.children == \"object\") {\r\n                var i = 0;\r\n                while(!found && i < e.children.length) {\r\n                    eTmp = unCD(e.children[i]);\r\n                    eTmp = unNode(e.children[i]);\r\n                    if(found = checkTag(eTmp)) e = eTmp;\r\n                    i++;\r\n                }\r\n            }\r\n            // look in direct \"parent\" element if not yet found\r\n            if(typeof e.parent == \"object\" && !found) {\r\n                eTmp = unCD(e.children[i]);\r\n                eTmp = unNode(e.children[i]);\r\n                if(found = checkTag(eTmp)) e = eTmp;\r\n            }\r\n        }\r\n        if(!found) throw msg;\r\n\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Wrapper calling C.magic with the object called on.\r\n     *\r\n     * @return native lib object\r\n     */\r\n    lib.magic = function() {\r\n        return C.magic.call(this, this);\r\n    }\r\n\r\n    /**\r\n     * Function to cartoonize any given svg.\r\n     *\r\n     * @param svgs source svg / selection with source svgs to cartoonize\r\n     * @return native lib object\r\n     */\r\n    C.magic = function(svgs) {\r\n        if(! svgs) return;\r\n        svgs = svgs[0] ? svgs : [svgs];\r\n        // rerun for list[i>0]; wont happen in reruns since then svgList.length = 1\r\n        for(var i = 1; i < svgs.length; i++) {\r\n            C.magic.call(this, unWrap(svgs[i]));\r\n        }\r\n        var svg = unWrap(svgs[0]);\r\n\r\n        // do depth-frist tree traversal & skip branches at unknown tags\r\n        (function walk(e) {\r\n            // recursion if known, unvisited tag - skip branch otherwise\r\n            var adj = e.children;\r\n            for(var i = 0; i < adj.length; i++) {\r\n                if( ! adj[i].hasOwnProperty(\"walked\") ) {\r\n                    adj[i].walked = true;\r\n                    if([\"rect\", \"circle\", \"ellipse\", \"line\", \"polyline\", \"polygon\",\r\n                        \"path\", \"g\", \"svg\"].indexOf(adj[i].tagName) >= 0) {\r\n                        walk.call(this, adj[i]);\r\n                    }\r\n                }\r\n            }\r\n            // do changes on the element\r\n            begin(); // we are using \"begin\" but wont be using \"finish\"\r\n            switch(e.tagName) {\r\n                case \"rect\":\r\n                    reRect.call(this, e);\r\n                    break;\r\n                case \"circle\":\r\n                    reCircle.call(this, e);\r\n                    break;\r\n                case \"ellipse\":\r\n                    reEllipse.call(this, e);\r\n                    break;\r\n                case \"line\":\r\n                    reLine.call(this, e);\r\n                    break;\r\n                case \"polyline\":\r\n                    rePolyline.call(this, e);\r\n                    break;\r\n                case \"polygon\":\r\n                    rePolygon.call(this, e);\r\n                    break;\r\n                case \"path\":\r\n                    rePath.call(this, e);\r\n                    break;\r\n                case \"g\":\r\n                    // nothing to do for \"g\"\r\n                    break;\r\n                case \"svg\":\r\n                    // nothing to do for \"svg\"\r\n                    break;\r\n                default:\r\n            }\r\n            // if a basic shape encountered replace it with path\r\n            // NOTE: we copy attributes, but loose event listeners!\r\n            var p = e;\r\n            if([\"rect\", \"circle\", \"ellipse\", \"line\",\r\n                \"polyline\", \"polygon\"].indexOf(e.tagName) >= 0) {\r\n                p = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n                // copy attributes, avoid those specific to non-paths\r\n                var atts = e.attributes;\r\n                for (var i = 0; i < atts.length; i++) {\r\n                    if([\"x\", \"y\", \"rx\", \"ry\", \"width\", \"height\", \"cx\", \"cy\", \"r\",\r\n                        \"x1\", \"y1\", \"x2\", \"y2\", \"points\"].indexOf(atts[i].name) < 0)\r\n                        p.setAttribute(atts[i].name, atts[i].value);\r\n                }\r\n                e.parentNode.replaceChild(p, e);\r\n            }\r\n            // if a path has been prepared adjust \"d\" attribute\r\n            if(pathStr.length > 0) {\r\n                p.setAttribute(\"d\", pathStr);\r\n            }\r\n        }).call(this, svg);\r\n\r\n        return svg;\r\n    }\r\n\r\n    /**\r\n     * Function to get SVGAnimatedLength values.\r\n     * @param e svg element\r\n     * @return number\r\n     */\r\n    var g = function(e) { return e.animVal.value; };\r\n\r\n    /**\r\n     * Function to redraw an svg rect in cartoon style.\r\n     *\r\n     * @param e svg rect element\r\n     * @return void\r\n     */\r\n    var reRect = function(e) {\r\n        // call internal method that only builds pathStr\r\n        cRect.call(this, g(e.x), g(e.y),\r\n                   g(e.width), g(e.height),\r\n                   g(e.rx), g(e.ry));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg circle in cartoon style.\r\n     *\r\n     * @param e svg circle element\r\n     * @return void\r\n     */\r\n    var reCircle = function(e) {\r\n        cCircle.call(this, g(e.cx), g(e.cy), g(e.r));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg ellipse in cartoon style.\r\n     *\r\n     * @param e svg ellipse element\r\n     * @return void\r\n     */\r\n    var reEllipse = function(e) {\r\n        cEllipse.call(this, g(e.cx), g(e.cy), g(e.rx), g(e.ry));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg line in cartoon style.\r\n     *\r\n     * @param e svg line element\r\n     * @return void\r\n     */\r\n    var reLine = function(e) {\r\n        cLine.call(this, g(e.x1), g(e.y1), g(e.x2), g(e.y2));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg polyline in cartoon style.\r\n     *\r\n     * @param e svg polyline element\r\n     * @return void\r\n     */\r\n    var rePolyline = function(e) {\r\n        var points = e.points;\r\n        var p1 = points.getItem(0);\r\n        for(var j = 1; j < points.length; j++) {\r\n            var p2 = points.getItem(j);\r\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\r\n            p1 = p2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg polygon in cartoon style.\r\n     *\r\n     * @param e svg polygon element\r\n     * @return void\r\n     */\r\n    var rePolygon = function(e) {\r\n        var points = e.points;\r\n        var p1 = points.getItem(0);\r\n        for(var j = 1; j < points.length; j++) {\r\n            var p2 = points.getItem(j);\r\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\r\n            p1 = p2;\r\n        }\r\n        p1 = points.getItem(0);\r\n        cLine.call(this, p2.x, p2.y, p1.x, p1.y);\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg path in cartoon style.\r\n     *\r\n     * @param e svg path element\r\n     * @return void\r\n     */\r\n    var rePath = function(e) {\r\n        var pos = { x:0, y:0 };  // SVG drawing position\r\n        var ipos = { x:0, y:0 }; // SVG initial position\r\n        var cpos = undefined;    // SVG last cubic bezier control point\r\n        var qpos = undefined;    // SVG last cubic bezier control point\r\n        var org = { x:0, y:-0 }; // coordinate origin\r\n        var cmds = parsePath(e);\r\n        for(var j = 0; j < cmds.length; j++) {\r\n            var cmd = cmds[j];\r\n            var name = cmd.shift();\r\n            var moveMadeAbs = false;\r\n            // special W3C rule if first cmd is rel. moveTo (impossible)\r\n            if(j == 0 && name == \"m\") {\r\n                name = \"M\";\r\n                moveMadeAbs = true;\r\n            }\r\n            // set origin either to absolute (0,0) or to relative (current pos)\r\n            var setOrg = function() {\r\n                org = (name == name.toUpperCase()) ?\r\n                      { x:0, y:0 } : { x:pos.x, y:pos.y };\r\n            };\r\n            setOrg();\r\n            switch(name) {\r\n                case \"M\": // \"move to\"\r\n                case \"m\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    // move pos\r\n                    pos = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                    ipos = pos; // set initial pos to pos moved to\r\n                    // revert special W3C rule if in effect\r\n                    name = moveMadeAbs ? \"m\" : \"M\";\r\n                    // further points are \"line to\"\r\n                    while(cmd.length > 1) {\r\n                        var p = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p.x, p.y);\r\n                        pos = p;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"Q\": // quadratic bezier\r\n                case \"q\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    while(cmd.length > 3) {\r\n                        // control point & end point\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\r\n                        pos = p2;\r\n                        qpos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"T\": // smooth / short hand quadratic bezier\r\n                case \"t\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    while(cmd.length > 1) {\r\n                        // end point\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        // control point is last control point reflection\r\n                        var p1 = (typeof qpos == \"undefined\") ? pos :\r\n                                  { x:2*pos.x-qpos.x, y:2*pos.y-qpos.y };\r\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\r\n                        pos = p2;\r\n                        qpos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"C\": // cubic bezier\r\n                case \"c\":\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 5) {\r\n                        // control points & end point\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\r\n                        pos = p3;\r\n                        cpos = p2;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"S\": // smooth / short hand cubic bezier\r\n                case \"s\":\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 3) {\r\n                        // 2nd control point & end point\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        // 1st control point is last control point reflection\r\n                        var p1 = (typeof cpos == \"undefined\") ? pos :\r\n                                  { x:2*pos.x-cpos.x, y:2*pos.y-cpos.y };\r\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\r\n                        pos = p3;\r\n                        cpos = p2;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"A\": // elliptic arc\r\n                case \"a\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 6) {\r\n                        var rx = Math.abs(cmd.shift()); // horizontal radius\r\n                        var ry = Math.abs(cmd.shift()); // vertical radius\r\n                        var rot = cmd.shift() % 360; // ellipse rotation\r\n                        var fa = !! cmd.shift(); // large arc flag\r\n                        var fs = !! cmd.shift(); // sweep flag\r\n                        var p1 = { x:org.x+cmd.shift(), // end point\r\n                                   y:org.y+cmd.shift() };\r\n                        // skip if end equals start & if rx & ry are 0\r\n                        if(p1.x == pos.x && p1.y == pos.y) continue;\r\n                        if(rx == 0 && ry == 0) continue;\r\n                        // do \"line to\" if rx XOR ry are 0\r\n                        if(rx == 0 || ry == 0) {\r\n                            // do horizontal or vertical \"line to\"\r\n                            p1 = (ry == 0) ? { x:p1.x, y:pos.y }\r\n                                 : { x:pos.x, y:p1.y };\r\n                            cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                            pos = p1;\r\n                            setOrg();\r\n                            continue;\r\n                        }\r\n                        // do normal elliptic arc if we got this far\r\n                        var retval = getEllipse(pos, p1, rx, ry, rot, fa, fs);\r\n                        var cp = retval[0];      // center point\r\n                        var start = retval[1].x; // start in radians\r\n                        var end = retval[1].y;   // end in radians\r\n                        cEllipse.call(this, cp.x, cp.y, rx, ry, rot, start, end);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"L\": // \"line to\"\r\n                case \"l\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 1) {\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"H\": // horizontal \"line to\"\r\n                case \"h\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 0) {\r\n                        var p1 = { x:org.x+cmd.shift(), y:pos.y };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"V\": // vertical \"line to\"\r\n                case \"v\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 0) {\r\n                        var p1 = { x:pos.x, y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"Z\": // \"close path\"\r\n                case \"z\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    cLine.call(this, pos.x, pos.y, ipos.x, ipos.y);\r\n                    pathStr = pathStr + \"z\";\r\n                    pos = ipos;\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @brief getEllipse calculates the center point and the start angle\r\n     * and end angle of an ellipse from the obscure SVG parameters of an\r\n     * elliptic arc. It returns an array with two points, the center\r\n     * point and a point with the start and end angles.\r\n     *\r\n     * @param ps starting point\r\n     * @param pe end point\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in degree\r\n     * @param fa large arc flag\r\n     * @param fs sweep flag\r\n     * @return array\r\n     */\r\n    var getEllipse = function(ps, pe, rh, rv, rot, fa, fs) {\r\n        // function for calculating angle between two vectors\r\n        var angle = function(u, v) {\r\n            var sign = ((u.x * v.y - u.y * v.x) >= 0) ? 1 : -1;\r\n            if(u.x == 0 && u.y == 0) return 0;\r\n            return sign * Math.acos(\r\n                (u.x * v.x + u.y * v.y) /\r\n                (Math.sqrt(u.x*u.x + u.y*u.y) * Math.sqrt(v.x*v.x + v.y*v.y))\r\n            );\r\n        }\r\n        // sanitize input\r\n        rot = rot % 360;\r\n        rh = Math.abs(rh);\r\n        rv = Math.abs(rv);\r\n        // do calculation\r\n        var twoPI = 2 * Math.PI;\r\n        var cosRot = Math.cos(rot);\r\n        var sinRot = Math.sin(rot);\r\n        var x = cosRot * (ps.x - pe.x) / 2 + sinRot * (ps.y - pe.y) / 2;\r\n        var y = -1 * sinRot * (ps.x - pe.x) / 2 + cosRot * (ps.y - pe.y) / 2;\r\n        var rh2 = rh * rh; var rv2 = rv * rv; var x2 = x * x; var y2 = y * y;\r\n        var fr = ((fa == fs) ? -1 : 1) * Math.sqrt(\r\n                    Math.abs(rh2 * (rv2 - y2) - rv2 * x2) /\r\n                    (rh2 * y2 + rv2 * x2)\r\n                 );\r\n        var xt = fr * rh * y / rv;\r\n        var yt = -1 * fr * rv * x / rh;\r\n        var cx = cosRot * xt - sinRot * yt + (ps.x + pe.x) / 2;\r\n        var cy = sinRot * xt + cosRot * yt + (ps.y + pe.y) / 2;\r\n        var vt = { x:(x-xt)/rh, y:(y-yt)/rv };\r\n        var phi1 = angle({ x:1, y:0 }, vt);\r\n        var phiD = angle(vt, { x:(-x-xt)/rh, y:(-y-yt)/rv }) % 360;\r\n        var phi2 = phi1 + phiD + (! fs && phiD > 0 ? -twoPI : 0) + (fs && phiD < 0 ? twoPI : 0);\r\n\r\n        return [{ x:cx, y:cy }, { x:phi1, y:phi2 }];\r\n    }\r\n\r\n    /**\r\n     * @brief De Casteljau's algorithm splitting n-th degree Bezier curve\r\n     *\r\n     * Given n+1 control points for an n-th degree Bezier curve and\r\n     * a number t between 0 and 1, it will return two arrays, each\r\n     * with n+1 new control points. The returned control points define\r\n     * two Bezier curves that together form the original Bezier curve\r\n     * in two peaces, split at the t-th point.\r\n     *\r\n     * @author Balint Morvai <balint@morvai.de>\r\n     * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n     */\r\n    var bsplit = function(points, t0) {\r\n        var n = points.length - 1; // number of control points\r\n        var b = [];       // coefficients as in De Casteljau's algorithm\r\n        var res1 = [];    // first curve resulting control points\r\n        var res2 = [];    // second curve resulting control points\r\n        var t1 = 1 - t0;\r\n\r\n        // multiply point with scalar factor\r\n        var pf = function(p, f) {\r\n            var res = [];\r\n            for(var i = 0; i < p.length; i++) {\r\n                res.push(f * p[i]);\r\n            }\r\n            return res;\r\n        };\r\n        // add points as vectors\r\n        var pp = function(p1, p2) {\r\n            var res = [];\r\n            for(var i = 0; i < Math.min(p1.length, p2.length); i++) {\r\n                res.push(p1[i] + p2[i]);\r\n            }\r\n            return res;\r\n        };\r\n\r\n        // set original coefficients: b[i][0] = points[i]\r\n        for(var i = 0; i <= n; i++) {\r\n            points[i] = (typeof points[i] == \"object\") ? points[i] : [points[i]];\r\n            b.push([ points[i] ]);\r\n        }\r\n        // get all coefficients\r\n        for(var j = 1; j <= n; j++) {\r\n            for(var i = 0; i <= (n-j); i++) {\r\n                b[i].push( pp(\r\n                        pf(b[i][j-1], t1),\r\n                        pf(b[i+1][j-1], t0)\r\n                ));\r\n            }\r\n        }\r\n        // set result: res1 & res2\r\n        for(var j = 0; j <= n; j++) {\r\n            res1.push(b[0][j]);\r\n            res2.push(b[j][n-j]);\r\n        }\r\n\r\n        return [res1, res2];\r\n    };\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * NOTE: not _really_ randomly but with alternating signs.\r\n     * Two times > 0, two times < 0, two times > 0, ... !\r\n     * NOTE: This relies on being called an even number of times\r\n     * from every context! (Which makes sense in a 2D space)\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzzDrunk = function(val, f) {\r\n        // get random sign\r\n        if(++fuzzDrunk.count > 2) {\r\n            fuzzDrunk.count = 0;\r\n            fuzzDrunk.sign *= -1;\r\n        }\r\n        return val + f * (rand() / 2 + fuzzDrunk.sign * 0.5);\r\n    }\r\n    fuzzDrunk.count = 0;\r\n    fuzzDrunk.sign = +(new Date()) % 2 ? 1 : -1; // random first sign\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * NOTE: not _really_ randomly, but with every 2nd call\r\n     * having a strong variation relative to the prior call.\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzzNormal = function(val, f) {\r\n        // get random number\r\n        var i = fuzzNormal.count;\r\n        var rnd = (rand() - 0.5);\r\n\r\n        if(++fuzzNormal.count == 2)\r\n            fuzzNormal.count = 0;\r\n\r\n        var res = val + f * (rnd - fuzzNormal.rnds[i]);\r\n        fuzzNormal.rnds[i] = rnd;\r\n\r\n        return res;\r\n    }\r\n    fuzzNormal.count = 0;\r\n    fuzzNormal.rnds = [0, 0];\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzz = function(val, f) {\r\n        return C.drunk ? fuzzDrunk(val, f) : fuzzNormal(val, f);\r\n    }\r\n\r\n    /**\r\n     * Distance between 2 numbers in 2 dim space\r\n     * @param x0 1st point x\r\n     * @param y0 1st point y\r\n     * @param x1 2nd point x\r\n     * @param y1 2nd point y\r\n     * @return number\r\n     */\r\n    var dist2 = function(x0, y0, x1, y1) {\r\n        var dx = x1 - x0;\r\n        var dy = y1 - y0;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    /**\r\n     * Test whether the given variable is an array.\r\n     * @param a var to test\r\n     * @return bool\r\n     */\r\n    var isArray = function(a) {\r\n        return Object.prototype.toString.call(a) === '[object Array]';\r\n    }\r\n\r\n    // ----------------------set drawing method-------------------------\r\n    // HTML5 Canvas context\r\n    if(libName == \"canvas\") {\r\n        path = function(x0, y0, cx, cy, x1, y1) {\r\n            this.moveTo(x0, y0);\r\n            this.quadraticCurveTo(cx, cy, x1, y1);\r\n            C.pathPos = { x:x1, y:y1 };\r\n        }\r\n        finish = function() {\r\n            this.stroke();\r\n            return this;\r\n        };\r\n        begin = function() {\r\n            this.beginPath();\r\n            return this;\r\n        };\r\n    }\r\n    else {\r\n        // for all svg libs let \"path\" & \"begin\" be as below\r\n        path = function(x0, y0, cx, cy, x1, y1) {\r\n            x0 = round(x0); y0 = round(y0); cx = round(cx);\r\n            cy = round(cy); x1 = round(x1); y1 = round(y1);\r\n            // \"move to\" only required if (x0, y0) != current pos AND as first path cmd\r\n            if(C.pathPos.x != x0 || C.pathPos.y != y0 || pathStr.length == 0) {\r\n                pathStr = pathStr + [\"M\", x0, y0, \"Q\", cx, cy, x1, y1].join(' ');\r\n            }\r\n            else {\r\n                pathStr = pathStr + [\"Q\", cx, cy, x1, y1].join(' ');\r\n            }\r\n            C.pathPos = { x:x1, y:y1 };\r\n            return this;\r\n        };\r\n        begin = function() {\r\n            pathStr = \"\";\r\n            C.pathPos = { x:0, y:0 };\r\n            return this;\r\n        };\r\n    }\r\n    // Raphael.js\r\n    if(libName == \"raphael\") {\r\n        finish = function() {\r\n            return this.path(pathStr);\r\n        };\r\n    }\r\n    // D3.js\r\n    if(libName == \"d3\") {\r\n        finish = function() {\r\n            return this.append(\"svg:path\").attr(\"d\", pathStr);\r\n        };\r\n    }\r\n    // SVG.js\r\n    if(libName == \"svg\") {\r\n        // draws path object from current pathStr on \"this\" & returns it\r\n        finish = function() {\r\n            return this.path(pathStr);\r\n        };\r\n    }\r\n}\r\nC.bindTo = bindTo;\r\n\r\n/**\r\n * @brief Round to the precision defined in local scope.\r\n *\r\n * @param {Float} x\r\n * @return {Float}\r\n */\r\nfunction round(x) {\r\n    return Math.round(x * roundFactor) / roundFactor;\r\n}\r\n\r\n/**\r\n * @brief Parse an svg path object and return commands\r\n * Parse an svg path object and generate an Array of path commands.\r\n * Each command is an Array of the form `[command, arg1, arg2, ...]`\r\n * NOTE: parsing is done via \"pathSegList\" which is faster and more\r\n * reliable than parsing the path string directly, but might not\r\n * work in old browsers.\r\n *\r\n * @author Balint Morvai <balint@morvai.de>\r\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n * @param {Object} path object\r\n * @return {Array}\r\n */\r\nfunction parsePath(path) {\r\n    // some browser bugs can make pathSegList go missing - a workaround\r\n    if(! path.pathSegList) {\r\n        var newPath = document.createElementNS(\"http://www.w3.org/2000/svg\", 'path');\r\n        newPath.setAttribute('d', path.getAttribute('d'));\r\n    }\r\n    var list = path.pathSegList || newPath.pathSegList;\r\n    if(! list.length) list = list._list;\r\n    var res = [];\r\n    for(var i = 0; i < list.length; i++) {\r\n        var cmd = list[i].pathSegTypeAsLetter;\r\n        var sub = [];\r\n        switch(cmd) {\r\n            case \"C\":\r\n            case \"c\":\r\n                sub.unshift(list[i].y2); sub.unshift(list[i].x2);\r\n            case \"Q\":\r\n            case \"q\":\r\n                sub.unshift(list[i].y1); sub.unshift(list[i].x1);\r\n            case \"M\":\r\n            case \"m\":\r\n            case \"L\":\r\n            case \"l\":\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"A\":\r\n            case \"a\":\r\n                sub.push(list[i].r1); sub.push(list[i].r2);\r\n                sub.push(list[i].angle);\r\n                sub.push(list[i].largeArcFlag);\r\n                sub.push(list[i].sweepFlag);\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"H\":\r\n            case \"h\":\r\n                sub.push(list[i].x);\r\n                break;\r\n            case \"V\":\r\n            case \"v\":\r\n                sub.push(list[i].y);\r\n                break;\r\n            case \"S\":\r\n            case \"s\":\r\n                sub.push(list[i].x2); sub.push(list[i].y2);\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"T\":\r\n            case \"t\":\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n        }\r\n        sub.unshift(cmd);\r\n        res.push(sub);\r\n    }\r\n    return res;\r\n}\r\n\r\n// set options\r\nC.init({\r\n    fsteps: fsteps,\r\n    msteps: msteps,\r\n    ff: ff,\r\n    ffc: ffc,\r\n    drunk: drunk,\r\n    context: context\r\n});\r\n\r\n// Raphael.js\r\nif(typeof Raphael != \"undefined\") {\r\n    bindTo(\"raphael\",   // library name\r\n           Raphael.fn); // root object to hook in to\r\n}\r\n\r\n// SVG.js\r\nif(typeof SVG != \"undefined\") {\r\n    var dummy = {};\r\n    bindTo(\"svg\", dummy);\r\n    SVG.extend(SVG.Set, dummy);\r\n    SVG.extend(SVG.Group, dummy);\r\n    SVG.extend(SVG.Element, dummy);\r\n}\r\n\r\n// D3.js\r\nif(typeof d3 != \"undefined\") {\r\n    bindTo(\"d3\", d3.selection.prototype);\r\n    bindTo(\"d3\", d3.selection.enter.prototype);\r\n}\r\n\r\n// comic.js - bind to self\r\nbindTo(\"self\", COMIC);\r\n\r\n})();\r\n"],"names":["COMIC","version","mulberry32","a","t","Math","imul","rand","C","begin","finish","path","pathStr","roundFactor","pow","pathPos","x","y","init","options","prop","hasOwnProperty","fsteps","bindTo","context","ctx","libName","lib","cBezier3","x0","y0","cx0","cy0","cx1","cy1","x1","y1","call","this","d","dist2","steps","ceil","f","ff","p0","pc0","pc1","p1","curve2","i","points","bsplit","curve1","fuzz","cBezier2","cx","cy","pc","cEllipse","rh","rv","rot","start","end","PI2","PI","cosRot","cos","sinRot","sin","msteps","fh","ffc","fv","rxs","rys","segLength","t1","cosT1rxs","sinT1rys","cLine","cCircle","r","xs","cTrian","x2","y2","cRect","width","height","halfPI","min","ft","hash1","hash2","reseed","handMovement","pow3","pow4","xt1","yt1","xt0","yt0","unWrap","e","found","tags","unCD","contentDocument","unNode","node","tagName","checkTag","indexOf","unArray","children","length","eTmp","parent","magic","svgs","svg","walk","adj","walked","reRect","reCircle","reEllipse","reLine","rePolyline","rePolygon","rePath","p","document","createElementNS","atts","attributes","name","setAttribute","value","parentNode","replaceChild","g","animVal","rx","ry","getItem","j","p2","pos","ipos","cpos","undefined","qpos","org","cmds","pathSegList","newPath","getAttribute","list","_list","res","cmd","pathSegTypeAsLetter","sub","unshift","push","r1","r2","angle","largeArcFlag","sweepFlag","parsePath","shift","moveMadeAbs","setOrg","toUpperCase","p3","abs","fa","fs","retval","getEllipse","cp","ps","pe","u","v","sign","acos","sqrt","twoPI","rh2","rv2","fr","xt","yt","vt","phi1","phiD","t0","n","b","res1","res2","pf","pp","fuzzDrunk","val","count","Date","fuzzNormal","rnd","rnds","drunk","dx","dy","moveTo","quadraticCurveTo","stroke","beginPath","round","join","append","attr","Raphael","fn","SVG","dummy","extend","Set","Group","Element","d3","selection","prototype","enter"],"sourceRoot":""}