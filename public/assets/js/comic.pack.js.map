{"version":3,"file":"comic.pack.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB,iBAAiB;;AAE/D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;;AAEnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,2CAA2C;AAC3C,wCAAwC;;AAExC,uBAAuB,YAAY;AACnC;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,gDAAgD;AAChD,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,qBAAqB,YAAY;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,oBAAoB,aAAa;AACjC;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,4BAA4B;AAC5B,gCAAgC;AAChC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,wDAAwD;AACxD,wDAAwD;AACxD,qDAAqD;AACrD,iDAAiD;AACjD,iDAAiD;AACjD,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,2BAA2B,UAAU;AACrC,+BAA+B,4BAA4B;AAC3D;;AAEA,kBAAkB,YAAY,IAAI,gBAAgB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC","sources":["./comic.js"],"sourcesContent":["/**\n * @brief Comic style version of common drawing functions.\n *\n * Comic style version of common drawing functions, that is\n * implemented as library agnostic JS extension. Only assuming\n * that given \"lib\" can be extended the JS way (setting properties)\n * and that if a \"path\" method is given, it is a drawing method\n * which understands standard SVG path format strings.\n * If no \"path\" is given, it will check if \"lib\" is a 2d canvas context\n * and use context drawing functions. If \"lib\" is not a 2d canvas\n * context, as last guess it will try to call an SVG \"path\" method\n * directly on the \"lib\" object.\n *\n * Credits:\n * Inspired by and based on Jonas Wagner's work\n * http://29a.ch/2010/2/10/hand-drawn-lines-algorithm-javascript-canvas-html5\n * which is based on this paper\n * http://iwi.eldoc.ub.rug.nl/FILES/root/2008/ProcCAGVIMeraj/2008ProcCAGVIMeraj.pdf\n *\n * @author Balint Morvai <balint@morvai.de>\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\n */\n// global object\nCOMIC = { version: 0.96 };\n\n(function () {\n\n   https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\n   function mulberry32(a) {\n      return function () {\n         var t = a += 0x6D2B79F5;\n         t = Math.imul(t ^ t >>> 15, t | 1);\n         t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n         return ((t ^ t >>> 14) >>> 0) / 4294967296;\n      }\n   }\n\n   var rand = mulberry32(0);\n\n   function reseed(x1, y1, x2, y2) {\n      // we re-seed based on x-y coords to give consistent values when a line starts or ends at the same point. \n      hash1 = (y1 << 16) ^ x1;\n      hash2 = (y2 << 16) ^ x2;\n\n      rand = mulberry32(hash1 + hash2);\r\n   }\n\n\n\n/**\n * @var object global \"C\" object\n */\nvar C = COMIC;\n/**\n * @var int length of one step - each step means new \"hand jitter\"\n */\nvar fsteps = 5;\n/**\n * @var int min number of steps\n */\nvar msteps = 3;\n/**\n * @var float fuzzyness factor\n */\nvar ff = 8.0;\n/**\n * @var float fuzzyness factor for circle & ellipse\n */\nvar ffc = 5.0;\n/**\n * @var float drunk style fuzzyness - everything has stronger curvature\n */\nvar drunk = false;\n/**\n * @var object 2d canvas context (if any)\n */\nvar context = undefined;\n/**\n * @var function code to execute when starting drawing a shape\n */\nvar begin = function() {};\n/**\n * @var function code to execute when finished drawing a shape\n */\nvar finish = function() {};\n/**\n * @var function code to draw comic path using specific user lib\n */\nvar path = function() {};\n/**\n * @var string path string built upon subsequent calls of \"path\" function\n */\nvar pathStr = \"\";\n/**\n * @var int decimal precision to which all drawing coordinates will be rounded\n */\nvar precision = 10;\n/**\n * @var int factor used by local \"round\" function, auto calculated from precision\n */\nvar roundFactor = Math.pow(10, precision);\n/**\n * @var point current drawing point of path - needed for continuous paths\n */\nC.pathPos = { x:0, y:0 };\n\n/**\n * Public function to allow user defined options, also\n * setting a 2d canvas context for drawing.\n *\n * @param options object with options\n * @return C object\n */\nC.init = function(options) {\n    // no need to deep copy & no need to drop unknown options\n    for(var prop in options) {\n        if(options.hasOwnProperty(prop)) {\n            C[prop] = options[prop];\n            // hard coded fudge factor\n            if(prop == 'fsteps')\n                C.fsteps *= 10;\n        }\n    }\n\n    // if new canvas context call bind to\n    if(typeof options[\"context\"] == \"object\") {\n        bindTo(\"canvas\", C.context);\n    }\n\n    return C;\n}\n\n/**\n * Public function to init drawing functions on the given\n * 2d canvas context.\n *\n * @param context 2d canvas context\n * @return C object\n */\nC.ctx = function(context) {\n    C.init({ \"context\": context });\n\n    return C;\n}\n\n/**\n * Binds comic drawing functions to the given library using the\n * given method to draw svg paths. If no method is given (2nd param),\n * it tries to call \"path\" directly on lib.\n *\n * @param libName root object to hook in to\n * @param lib root object to hook in to\n * @return void\n */\nvar bindTo = function(libName, lib) {\n    /**\n     * WRAPPER for real, private \"cBezier3\"\n     * hand draw a cubic Bezier curve\n     *\n     * @param x0 x starting point\n     * @param y0 y starting point\n     * @param cx0 x 1st control point\n     * @param cy0 y 1st control point\n     * @param cx1 x 2nd control point\n     * @param cy1 y 2nd control point\n     * @param x1 x end point\n     * @param y1 y end point\n     * @return native library object\n     */\n    lib.cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\n        begin.call(this);\n        cBezier3.call(this, x0, y0, cx0, cy0, cx1, cy1, x1, y1);\n        return finish.call(this);\n    }\n\n    /**\n     * Private version that does not call \"begin\" or \"finish\".\n     * Wrapped by \"cBezier3\" public.\n     * hand draw a cubic Bezier curve\n     *\n     * @param x0 x starting point\n     * @param y0 y starting point\n     * @param cx0 x 1st control point\n     * @param cy0 y 1st control point\n     * @param cx1 x 2nd control point\n     * @param cy1 y 2nd control point\n     * @param x1 x end point\n     * @param y1 y end point\n     * @return native library object\n     */\n    var cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\n        // number of steps - this is a very primitive approach to\n        // estimate the Bezier arc length\n        var d = dist2(x0, y0, x1, y1) * 3;\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\n        // fuzzyness\n        var f = C.ff * 0.8;\n\n        var p0 = [x0, y0];\n        var pc0 = [cx0, cy0];\n        var pc1 = [cx1, cy1];\n        var p1 = [x1, y1];\n        var curve2 = [p0, pc0, pc1, p1];\n        for(var i = steps; i > 0; i--) {\n            // split curve2\n            var points = bsplit(curve2, 1/i);\n            var curve1 = points[0];\n            var curve2 = points[1];\n            // set points for drawing from curve1\n            p0 = curve1[0]; pc0 = curve1[1];  pc1 = curve1[2]; p1 = curve1[3];\n\n            path.call(this, p0[0], p0[1],\n                fuzz((pc0[0]+pc1[0])/2, f), // just make one control point\n                fuzz((pc0[1]+pc1[1])/2, f),\n                p1[0], p1[1]);\n        }\n\n        return this;\n    }\n\n    /**\n     * WRAPPER for real, private \"cBezier2\"\n     * hand draw a quadratic Bezier curve\n     *\n     * @param x0 x starting point\n     * @param y0 y starting point\n     * @param cx x control point\n     * @param cy y control point\n     * @param x1 x end point\n     * @param y1 y end point\n     * @return native library object\n     */\n    lib.cBezier2 = function(x0, y0, cx, cy, x1, y1) {\n        begin.call(this);\n        cBezier2.call(this, x0, y0, cx, cy, x1, y1);\n        return finish.call(this);\n    }\n\n    /**\n     * Private version that does not call \"begin\" or \"finish\".\n     * Wrapped by \"cBezier2\" public.\n     * hand draw a quadratic Bezier curve\n     *\n     * @param x0 x starting point\n     * @param y0 y starting point\n     * @param cx x control point\n     * @param cy y control point\n     * @param x1 x end point\n     * @param y1 y end point\n     * @return native library object\n     */\n    var cBezier2 = function(x0, y0, cx, cy, x1, y1) {\n        // number of steps - this is a very primitive approach to\n        // estimate the Bezier arc length\n        var d = dist2(x0, y0, x1, y1) * 3;\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\n        // fuzzyness\n        var f = C.ff * 0.8;\n\n        var p0 = [x0, y0];\n        var pc = [cx, cy];\n        var p1 = [x1, y1];\n        var curve2 = [p0, pc, p1];\n        for(var i = steps; i > 0; i--) {\n            // split curve2\n            var points = bsplit(curve2, 1/i);\n            var curve1 = points[0];\n            var curve2 = points[1];\n            // set points for drawing from curve1\n            p0 = curve1[0]; pc = curve1[1]; p1 = curve1[2];\n\n            path.call(this, p0[0], p0[1], fuzz(pc[0], f), fuzz(pc[1], f), p1[0], p1[1]);\n        }\n\n        return this;\n    }\n\n    /**\n     * WRAPPER for real, private \"cEllipse\"\n     * Draw a comic style / hand drawn cEllipse\n     *\n     * @param x x center\n     * @param y y center\n     * @param rh horizontal radius\n     * @param rv vertical radius\n     * @param rot rotation in radians\n     * @param start start in radians for drawing an arc only (optional)\n     * @param end end in radians for drawing an arc only (optional)\n     * @return native library object\n     */\n    lib.cEllipse = function(x, y, rh, rv, rot, start, end) {\n        begin.call(this);\n        cEllipse.call(this, x, y, rh, rv, rot, start, end);\n        return finish.call(this);\n    }\n\n    /**\n     * Private version that does not call \"begin\" or \"finish\".\n     * Wrapped by \"cEllipse\" public.\n     * hand draw an ellipse\n     *\n     * @param x x center\n     * @param y y center\n     * @param rh horizontal radius\n     * @param rv vertical radius\n     * @param rot rotation in radians\n     * @param start start in radians for drawing an arc only (optional)\n     * @param end end in radians for drawing an arc only (optional)\n     * @return native library object\n     */\n    var cEllipse = function(x, y, rh, rv, rot, start, end) {\n        var PI2 = Math.PI * 2;\n        // sanitize input\n        start = (typeof start == \"undefined\") ? 0 : start;\n        end = (typeof end == \"undefined\") ? PI2 : end;\n        rot = (typeof rot == \"undefined\") ? 0 : rot;\n        // rotation\n        var cosRot = Math.cos(rot);\n        var sinRot = Math.sin(rot);\n        // number of steps\n        var steps = C.msteps + ((rh + rv) / 2) * C.fsteps / 200;\n        // fuzzyness dependent on on radius\n        var fh = C.ffc * Math.pow(rh, 0.5) * 0.3 / Math.pow(steps, 0.25);\n        var fv = C.ffc * Math.pow(rv, 0.5) * 0.3 / Math.pow(steps, 0.25);\n        // distortion of the ellipse\n        var xs = 0.95 + rand() * 0.1;\n       var ys = 0.95 + rand() * 0.1;\n        var rxs = rh * xs;\n        var rys = rv * ys;\n        // lenght of one segment\n        var arcLength = end - start;\n        var segLength = arcLength / steps;\n\n        // initial values for i = 0\n        var t1 = start; var t0, x0, y0;\n        var cosT1rxs = rxs * Math.cos(t1);\n        var sinT1rys = rys * Math.sin(t1);\n        var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\n        var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\n\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\n        cLine.call(this,\n                   x + rh * Math.cos(t1) * cosRot - rv * Math.sin(t1) * sinRot, // would be start x\n                   y + rh * Math.cos(t1) * sinRot + rv * Math.sin(t1) * cosRot, // would be start y\n                   x1,  // actual start x\n                   y1); // actual start y\n\n        for(var i = 1; i <= steps; i++) {\n            t1 = t1 + segLength;\n            var x0 = x1;\n            var y0 = y1;\n            var cosT1rxs = rxs * Math.cos(t1);\n            var sinT1rys = rys * Math.sin(t1);\n            var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\n            var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\n\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, fh), fuzz((y0 + y1) / 2, fv), x1, y1);\n        }\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\n        cLine.call(this,\n                   x1, // actual end x\n                   y1, // actual end y\n                   x + rh * Math.cos(end) * cosRot - rv * Math.sin(end) * sinRot,  // would be end x\n                   y + rh * Math.cos(end) * sinRot + rv * Math.sin(end) * cosRot); // would be end y\n\n        return this;\n    }\n\n    /**\n     * WRAPPER for real, private \"cCircle\"\n     * Draw a comic style / hand drawn circle\n     *\n     * @param x x center\n     * @param y y center\n     * @param r radius\n     * @param start start in radians (< 2*PI) for drawing an arc only (optional)\n     * @param end end in radians (< 2*PI) for drawing an arc only (optional)\n     * @return native library object\n     */\n    lib.cCircle = function(x, y, r, start, end) {\n        begin.call(this);\n        cCircle.call(this, x, y, r, start, end);\n        return finish.call(this);\n    }\n\n    /**\n     * Private version that does not call \"begin\" or \"finish\".\n     * Wrapped by \"cCircle\" public.\n     * hand draw a circle\n     *\n     * @param x x center\n     * @param y y center\n     * @param r radius\n     * @param start start in radians for drawing an arc only (optional)\n     * @param end end in radians for drawing an arc only (optional)\n     * @return native library object\n     */\n    var cCircle = function(x, y, r, start, end) {\n        var PI2 = Math.PI * 2;\n        // sanitize input\n        start = (typeof start == \"undefined\") ? 0 : start;\n        end = (typeof end == \"undefined\") ? PI2 : end;\n        // number of steps\n        var steps = C.msteps + r * C.fsteps / 200;\n        // fuzzyness dependent on on radius\n        var f = C.ffc * Math.pow(r, 0.5) * 0.3 / Math.pow(steps, 0.25);\n        // distortion of the circle\n        var xs = 0.975 + rand() * 0.05;\n        var rxs = r * xs;\n        var rys = r * (2.0 - xs);\n        // lenght of one segment\n        var arcLength = end - start;\n        var segLength = arcLength / steps;\n\n        // initial values for i = 0\n        var t1 = start; var t0, x0, y0;\n        var x1 = x + Math.cos(t1) * rxs;\n        var y1 = y + Math.sin(t1) * rys; // initial values for i = 0\n\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\n        cLine.call(this,\n                   x + Math.cos(t1) * r, // would be start x\n                   y + Math.sin(t1) * r, // would be start y\n                   x1,  // actual start x\n                   y1); // actual start y\n\n        for(var i = 1; i <= steps; i++) {\n            t1 = t1 + segLength;\n            x0 = x1;\n            y0 = y1;\n            x1 = x + Math.cos(t1) * rxs;\n            y1 = y + Math.sin(t1) * rys;\n\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, f), fuzz((y0 + y1) / 2, f), x1, y1);\n        }\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\n        cLine.call(this,\n                   x1, // actual end x\n                   y1, // actual end y\n                   x + Math.cos(end) * r,  // would be end x\n                   y + Math.sin(end) * r); // would be end y\n\n        return this;\n    }\n\n    /**\n     * Draw a triangle using line function\n     *\n     * @param x0 x first point\n     * @param y0 y first point\n     * @param x1 x second point\n     * @param y1 y second point\n     * @param x2 x third point\n     * @param y2 y third point\n     * @return native library object\n     */\n    lib.cTrian = function(x0, y0, x1, y1, x2, y2) {\n        begin.call(this);\n        cLine.call(this, x0, y0, x1, y1);\n        cLine.call(this, x1, y1, x2, y2);\n        cLine.call(this, x2, y2, x0, y0);\n        return finish.call(this);\n    }\n\n    /**\n     * WRAPPER for real, private \"cRect\"\n     * Draw a comic style / hand drawn rectangle using line function\n     *\n     * @param x0 x upper left corcer\n     * @param y0 y upper left corner\n     * @param width width of the rectangle\n     * @param height height of the rectangle\n     * @param rh horizontal radius of rounded corners\n     * @param rv vertical radius of rounded corners\n     * @return native library object\n     */\n    lib.cRect = function(x0, y0, width, height, rh, rv) {\n        begin.call(this);\n        cRect.call(this, x0, y0, width, height, rh, rv);\n        return finish.call(this);\n    }\n\n    /**\n     * Private version that does not call \"begin\" or \"finish\".\n     * Wrapped by \"cRect\" public.\n     * Draw a comic style / hand drawn rectangle using line function\n     *\n     * @param x0 x upper left corcer\n     * @param y0 y upper left corner\n     * @param width width of the rectangle\n     * @param height height of the rectangle\n     * @param rh horizontal radius of rounded corners\n     * @param rv vertical radius of rounded corners\n     * @return native library object\n     */\n    var cRect = function(x0, y0, width, height, rh, rv) {\n        var halfPI;\n        // sanitize input\n        rh = (typeof rh == \"undefined\") ? 0 : Math.min(rh, width/2);\n        rv = (typeof rv == \"undefined\") ? rh : Math.min(rv, height/2);\n        // calculate lower left corner\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        cLine.call(this, x0+rh, y0, x1-rh, y0);\n        if(rh > 0) {\n            halfPI = Math.PI / 2;\n            cEllipse.call(this, x1-rh, y0+rv, rh, rv, 0, halfPI*3, Math.PI*2);\n        }\n        cLine.call(this, x1, y0+rv, x1, y1-rv);\n        if(rh > 0) {\n            cEllipse.call(this, x1-rh, y1-rv, rh, rv, 0, 0, halfPI);\n        }\n        cLine.call(this, x1-rh, y1, x0+rh, y1);\n        if(rh > 0) {\n            cEllipse.call(this, x0+rh, y1-rv, rh, rv, 0, halfPI, Math.PI);\n        }\n        cLine.call(this, x0, y1-rv, x0, y0+rv);\n        if(rh > 0) {\n            cEllipse.call(this, x0+rh, y0+rv, rh, rv, 0, Math.PI, halfPI*3);\n        }\n\n        return this;\n    }\n\n    /**\n     * WRAPPER for real, private \"cLine\"\n     * Draw a comic style / hand drawn line\n     *\n     * @param x0 x start\n     * @param y0 y start\n     * @param x1 x end\n     * @param y1 y end\n     * @return native library object\n     */\n    lib.cLine = function(x0, y0, x1, y1) {\n        begin.call(this);\n        cLine.call(this, x0, y0, x1, y1);\n        return finish.call(this);\n    }\n\n    /**\n     * Private version that does not call \"begin\" or \"finish\".\n     * Wrapped by \"cLine\" public.\n     * Draw a comic style / hand drawn line\n     *\n     * @param x0 x start\n     * @param y0 y start\n     * @param x1 x end\n     * @param y1 y end\n     * @return native library object\n     */\n   var cLine = function (x0, y0, x1, y1) {\n\n      reseed(x0, y0);\n\n        /**\n         * Estimate the movement of the arm\n         * Reuses 3rd param from last call if omitted\n         *\n         * @param x0 x start\n         * @param x1 x end\n         * @param t step from 0 to 1\n         * @return number\n         */\n        var ft; // store this outside function to preserve\n        var handMovement = function(x0, x1, t) {\n            // calculate ft or use old value if no \"t\" given\n            if(typeof t != \"undefined\") {\n                var pow3 = Math.pow(t, 3);\n                var pow4 = pow3 * t;\n                var pow5 = pow4 * t;\n                ft = (15 * pow4 -\n                      6 * pow5 -\n                      10 * pow3);\n            }\n\n            return x0 + (x0 - x1) * ft;\n        }\n\n        // calculate number of steps\n        var d = dist2(x0, y0, x1, y1);\n        var steps = Math.ceil(d / C.fsteps);\n        if(steps < C.msteps) {\n            steps = C.msteps;\n        }\n        // fuzz factor\n        f = C.ff / ((steps == C.msteps) ? 1.4 : 1); // reduce for small lines\n        // draw line step by step using quadratic Bézier path\n        var xt1 = handMovement(x0, x1, 0); // bezier control point\n        var yt1 = handMovement(y0, y1); // bezier control point (reuse t0)\n\n        for(var i = 1; i <= steps; i++) {\n            t1 = i / steps;\n            var xt0 = xt1; // bezier control point\n            var yt0 = yt1; // bezier control point\n            var xt1 = handMovement(x0, x1, t1); // bezier end point\n            var yt1 = handMovement(y0, y1); // bezier end point (reuse t1)\n\n            path.call(this, xt0, yt0, fuzz((xt0 + xt1) / 2, f), fuzz((yt0 + yt1) / 2, f), xt1, yt1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Smart function for digesting input given to \"magic\" function.\n     * It looks for valid drawing elements, svg & g, and tries to find\n     * them in SVGDocument, Node and in direct children and parent\n     * elements.\n     *\n     * @param e Node or Element\n     * @return element\n     */\n    var unWrap = function(e) {\n        var msg = \"error: no drawing element given\"; // in case of error\n        found = false; // false until valid drawing object found\n        tags = [\"svg\", \"g\"] // array of valid drawing tags\n        var unArray = function(e) {\n            // \"string\" of course is nonsense but would cause infinite loop\n            while(e[0] && typeof e[0] != \"string\") {\n                e = e[0];\n            }\n            return e;\n        }\n        // unwrap from e.g. SVGDocument\n        var unCD = function(e) {\n            if(e.contentDocument) e = e.contentDocument;\n            return e;\n        }\n        // look in the \"node\"\n        var unNode = function(e) {\n            if(typeof e.node == \"object\") {\n                if(typeof e.node.tagName == \"string\")\n                    e = e.node;\n            }\n            return e;\n        }\n        var checkTag = function(e) {\n            return (typeof e.tagName != \"string\") ?\n                    false : tags.indexOf(e.tagName) >= 0;\n        }\n        e = unArray(e);\n        e = unCD(e);\n        e = unNode(e);\n        // looking for an element, not any node, thus with \"tagName\"\n        if(! (found = checkTag(e)) ) {\n            // look in direct \"child\" elements\n            if(typeof e.children == \"object\") {\n                var i = 0;\n                while(!found && i < e.children.length) {\n                    eTmp = unCD(e.children[i]);\n                    eTmp = unNode(e.children[i]);\n                    if(found = checkTag(eTmp)) e = eTmp;\n                    i++;\n                }\n            }\n            // look in direct \"parent\" element if not yet found\n            if(typeof e.parent == \"object\" && !found) {\n                eTmp = unCD(e.children[i]);\n                eTmp = unNode(e.children[i]);\n                if(found = checkTag(eTmp)) e = eTmp;\n            }\n        }\n        if(!found) throw msg;\n\n        return e;\n    }\n\n    /**\n     * Wrapper calling C.magic with the object called on.\n     *\n     * @return native lib object\n     */\n    lib.magic = function() {\n        return C.magic.call(this, this);\n    }\n\n    /**\n     * Function to cartoonize any given svg.\n     *\n     * @param svgs source svg / selection with source svgs to cartoonize\n     * @return native lib object\n     */\n    C.magic = function(svgs) {\n        if(! svgs) return;\n        svgs = svgs[0] ? svgs : [svgs];\n        // rerun for list[i>0]; wont happen in reruns since then svgList.length = 1\n        for(var i = 1; i < svgs.length; i++) {\n            C.magic.call(this, unWrap(svgs[i]));\n        }\n        var svg = unWrap(svgs[0]);\n\n        // do depth-frist tree traversal & skip branches at unknown tags\n        (function walk(e) {\n            // recursion if known, unvisited tag - skip branch otherwise\n            var adj = e.children;\n            for(var i = 0; i < adj.length; i++) {\n                if( ! adj[i].hasOwnProperty(\"walked\") ) {\n                    adj[i].walked = true;\n                    if([\"rect\", \"circle\", \"ellipse\", \"line\", \"polyline\", \"polygon\",\n                        \"path\", \"g\", \"svg\"].indexOf(adj[i].tagName) >= 0) {\n                        walk.call(this, adj[i]);\n                    }\n                }\n            }\n            // do changes on the element\n            begin(); // we are using \"begin\" but wont be using \"finish\"\n            switch(e.tagName) {\n                case \"rect\":\n                    reRect.call(this, e);\n                    break;\n                case \"circle\":\n                    reCircle.call(this, e);\n                    break;\n                case \"ellipse\":\n                    reEllipse.call(this, e);\n                    break;\n                case \"line\":\n                    reLine.call(this, e);\n                    break;\n                case \"polyline\":\n                    rePolyline.call(this, e);\n                    break;\n                case \"polygon\":\n                    rePolygon.call(this, e);\n                    break;\n                case \"path\":\n                    rePath.call(this, e);\n                    break;\n                case \"g\":\n                    // nothing to do for \"g\"\n                    break;\n                case \"svg\":\n                    // nothing to do for \"svg\"\n                    break;\n                default:\n            }\n            // if a basic shape encountered replace it with path\n            // NOTE: we copy attributes, but loose event listeners!\n            var p = e;\n            if([\"rect\", \"circle\", \"ellipse\", \"line\",\n                \"polyline\", \"polygon\"].indexOf(e.tagName) >= 0) {\n                p = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n                // copy attributes, avoid those specific to non-paths\n                var atts = e.attributes;\n                for (var i = 0; i < atts.length; i++) {\n                    if([\"x\", \"y\", \"rx\", \"ry\", \"width\", \"height\", \"cx\", \"cy\", \"r\",\n                        \"x1\", \"y1\", \"x2\", \"y2\", \"points\"].indexOf(atts[i].name) < 0)\n                        p.setAttribute(atts[i].name, atts[i].value);\n                }\n                e.parentNode.replaceChild(p, e);\n            }\n            // if a path has been prepared adjust \"d\" attribute\n            if(pathStr.length > 0) {\n                p.setAttribute(\"d\", pathStr);\n            }\n        }).call(this, svg);\n\n        return svg;\n    }\n\n    /**\n     * Function to get SVGAnimatedLength values.\n     * @param e svg element\n     * @return number\n     */\n    var g = function(e) { return e.animVal.value; };\n\n    /**\n     * Function to redraw an svg rect in cartoon style.\n     *\n     * @param e svg rect element\n     * @return void\n     */\n    var reRect = function(e) {\n        // call internal method that only builds pathStr\n        cRect.call(this, g(e.x), g(e.y),\n                   g(e.width), g(e.height),\n                   g(e.rx), g(e.ry));\n    }\n\n    /**\n     * Function to redraw an svg circle in cartoon style.\n     *\n     * @param e svg circle element\n     * @return void\n     */\n    var reCircle = function(e) {\n        cCircle.call(this, g(e.cx), g(e.cy), g(e.r));\n    }\n\n    /**\n     * Function to redraw an svg ellipse in cartoon style.\n     *\n     * @param e svg ellipse element\n     * @return void\n     */\n    var reEllipse = function(e) {\n        cEllipse.call(this, g(e.cx), g(e.cy), g(e.rx), g(e.ry));\n    }\n\n    /**\n     * Function to redraw an svg line in cartoon style.\n     *\n     * @param e svg line element\n     * @return void\n     */\n    var reLine = function(e) {\n        cLine.call(this, g(e.x1), g(e.y1), g(e.x2), g(e.y2));\n    }\n\n    /**\n     * Function to redraw an svg polyline in cartoon style.\n     *\n     * @param e svg polyline element\n     * @return void\n     */\n    var rePolyline = function(e) {\n        var points = e.points;\n        var p1 = points.getItem(0);\n        for(var j = 1; j < points.length; j++) {\n            var p2 = points.getItem(j);\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\n            p1 = p2;\n        }\n    }\n\n    /**\n     * Function to redraw an svg polygon in cartoon style.\n     *\n     * @param e svg polygon element\n     * @return void\n     */\n    var rePolygon = function(e) {\n        var points = e.points;\n        var p1 = points.getItem(0);\n        for(var j = 1; j < points.length; j++) {\n            var p2 = points.getItem(j);\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\n            p1 = p2;\n        }\n        p1 = points.getItem(0);\n        cLine.call(this, p2.x, p2.y, p1.x, p1.y);\n    }\n\n    /**\n     * Function to redraw an svg path in cartoon style.\n     *\n     * @param e svg path element\n     * @return void\n     */\n    var rePath = function(e) {\n        var pos = { x:0, y:0 };  // SVG drawing position\n        var ipos = { x:0, y:0 }; // SVG initial position\n        var cpos = undefined;    // SVG last cubic bezier control point\n        var qpos = undefined;    // SVG last cubic bezier control point\n        var org = { x:0, y:-0 }; // coordinate origin\n        var cmds = parsePath(e);\n        for(var j = 0; j < cmds.length; j++) {\n            var cmd = cmds[j];\n            var name = cmd.shift();\n            var moveMadeAbs = false;\n            // special W3C rule if first cmd is rel. moveTo (impossible)\n            if(j == 0 && name == \"m\") {\n                name = \"M\";\n                moveMadeAbs = true;\n            }\n            // set origin either to absolute (0,0) or to relative (current pos)\n            var setOrg = function() {\n                org = (name == name.toUpperCase()) ?\n                      { x:0, y:0 } : { x:pos.x, y:pos.y };\n            };\n            setOrg();\n            switch(name) {\n                case \"M\": // \"move to\"\n                case \"m\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    qpos = undefined; // unset last quadratic bezier control point\n                    // move pos\n                    pos = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                    ipos = pos; // set initial pos to pos moved to\n                    // revert special W3C rule if in effect\n                    name = moveMadeAbs ? \"m\" : \"M\";\n                    // further points are \"line to\"\n                    while(cmd.length > 1) {\n                        var p = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        cLine.call(this, pos.x, pos.y, p.x, p.y);\n                        pos = p;\n                        setOrg();\n                    }\n                    break;\n                case \"Q\": // quadratic bezier\n                case \"q\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    while(cmd.length > 3) {\n                        // control point & end point\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\n                        pos = p2;\n                        qpos = p1;\n                        setOrg();\n                    }\n                    break;\n                case \"T\": // smooth / short hand quadratic bezier\n                case \"t\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    while(cmd.length > 1) {\n                        // end point\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        // control point is last control point reflection\n                        var p1 = (typeof qpos == \"undefined\") ? pos :\n                                  { x:2*pos.x-qpos.x, y:2*pos.y-qpos.y };\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\n                        pos = p2;\n                        qpos = p1;\n                        setOrg();\n                    }\n                    break;\n                case \"C\": // cubic bezier\n                case \"c\":\n                    qpos = undefined; // unset last quadratic bezier control point\n                    while(cmd.length > 5) {\n                        // control points & end point\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n                        pos = p3;\n                        cpos = p2;\n                        setOrg();\n                    }\n                    break;\n                case \"S\": // smooth / short hand cubic bezier\n                case \"s\":\n                    qpos = undefined; // unset last quadratic bezier control point\n                    while(cmd.length > 3) {\n                        // 2nd control point & end point\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        // 1st control point is last control point reflection\n                        var p1 = (typeof cpos == \"undefined\") ? pos :\n                                  { x:2*pos.x-cpos.x, y:2*pos.y-cpos.y };\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n                        pos = p3;\n                        cpos = p2;\n                        setOrg();\n                    }\n                    break;\n                case \"A\": // elliptic arc\n                case \"a\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    qpos = undefined; // unset last quadratic bezier control point\n                    while(cmd.length > 6) {\n                        var rx = Math.abs(cmd.shift()); // horizontal radius\n                        var ry = Math.abs(cmd.shift()); // vertical radius\n                        var rot = cmd.shift() % 360; // ellipse rotation\n                        var fa = !! cmd.shift(); // large arc flag\n                        var fs = !! cmd.shift(); // sweep flag\n                        var p1 = { x:org.x+cmd.shift(), // end point\n                                   y:org.y+cmd.shift() };\n                        // skip if end equals start & if rx & ry are 0\n                        if(p1.x == pos.x && p1.y == pos.y) continue;\n                        if(rx == 0 && ry == 0) continue;\n                        // do \"line to\" if rx XOR ry are 0\n                        if(rx == 0 || ry == 0) {\n                            // do horizontal or vertical \"line to\"\n                            p1 = (ry == 0) ? { x:p1.x, y:pos.y }\n                                 : { x:pos.x, y:p1.y };\n                            cLine.call(this, pos.x, pos.y, p1.x, p1.y);\n                            pos = p1;\n                            setOrg();\n                            continue;\n                        }\n                        // do normal elliptic arc if we got this far\n                        var retval = getEllipse(pos, p1, rx, ry, rot, fa, fs);\n                        var cp = retval[0];      // center point\n                        var start = retval[1].x; // start in radians\n                        var end = retval[1].y;   // end in radians\n                        cEllipse.call(this, cp.x, cp.y, rx, ry, rot, start, end);\n                        pos = p1;\n                        setOrg();\n                    }\n                    break;\n                case \"L\": // \"line to\"\n                case \"l\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    qpos = undefined; // unset last quadratic bezier control point\n                    while(cmd.length > 1) {\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\n                        pos = p1;\n                        setOrg();\n                    }\n                    break;\n                case \"H\": // horizontal \"line to\"\n                case \"h\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    qpos = undefined; // unset last quadratic bezier control point\n                    while(cmd.length > 0) {\n                        var p1 = { x:org.x+cmd.shift(), y:pos.y };\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\n                        pos = p1;\n                        setOrg();\n                    }\n                    break;\n                case \"V\": // vertical \"line to\"\n                case \"v\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    qpos = undefined; // unset last quadratic bezier control point\n                    while(cmd.length > 0) {\n                        var p1 = { x:pos.x, y:org.y+cmd.shift() };\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\n                        pos = p1;\n                        setOrg();\n                    }\n                    break;\n                case \"Z\": // \"close path\"\n                case \"z\":\n                    cpos = undefined; // unset last cubic bezier control point\n                    qpos = undefined; // unset last quadratic bezier control point\n                    cLine.call(this, pos.x, pos.y, ipos.x, ipos.y);\n                    pathStr = pathStr + \"z\";\n                    pos = ipos;\n                    break;\n                default:\n            }\n        }\n    }\n\n    /**\n     * @brief getEllipse calculates the center point and the start angle\n     * and end angle of an ellipse from the obscure SVG parameters of an\n     * elliptic arc. It returns an array with two points, the center\n     * point and a point with the start and end angles.\n     *\n     * @param ps starting point\n     * @param pe end point\n     * @param rh horizontal radius\n     * @param rv vertical radius\n     * @param rot rotation in degree\n     * @param fa large arc flag\n     * @param fs sweep flag\n     * @return array\n     */\n    var getEllipse = function(ps, pe, rh, rv, rot, fa, fs) {\n        // function for calculating angle between two vectors\n        var angle = function(u, v) {\n            var sign = ((u.x * v.y - u.y * v.x) >= 0) ? 1 : -1;\n            if(u.x == 0 && u.y == 0) return 0;\n            return sign * Math.acos(\n                (u.x * v.x + u.y * v.y) /\n                (Math.sqrt(u.x*u.x + u.y*u.y) * Math.sqrt(v.x*v.x + v.y*v.y))\n            );\n        }\n        // sanitize input\n        rot = rot % 360;\n        rh = Math.abs(rh);\n        rv = Math.abs(rv);\n        // do calculation\n        var twoPI = 2 * Math.PI;\n        var cosRot = Math.cos(rot);\n        var sinRot = Math.sin(rot);\n        var x = cosRot * (ps.x - pe.x) / 2 + sinRot * (ps.y - pe.y) / 2;\n        var y = -1 * sinRot * (ps.x - pe.x) / 2 + cosRot * (ps.y - pe.y) / 2;\n        var rh2 = rh * rh; var rv2 = rv * rv; var x2 = x * x; var y2 = y * y;\n        var fr = ((fa == fs) ? -1 : 1) * Math.sqrt(\n                    Math.abs(rh2 * (rv2 - y2) - rv2 * x2) /\n                    (rh2 * y2 + rv2 * x2)\n                 );\n        var xt = fr * rh * y / rv;\n        var yt = -1 * fr * rv * x / rh;\n        var cx = cosRot * xt - sinRot * yt + (ps.x + pe.x) / 2;\n        var cy = sinRot * xt + cosRot * yt + (ps.y + pe.y) / 2;\n        var vt = { x:(x-xt)/rh, y:(y-yt)/rv };\n        var phi1 = angle({ x:1, y:0 }, vt);\n        var phiD = angle(vt, { x:(-x-xt)/rh, y:(-y-yt)/rv }) % 360;\n        var phi2 = phi1 + phiD + (! fs && phiD > 0 ? -twoPI : 0) + (fs && phiD < 0 ? twoPI : 0);\n\n        return [{ x:cx, y:cy }, { x:phi1, y:phi2 }];\n    }\n\n    /**\n     * @brief De Casteljau's algorithm splitting n-th degree Bezier curve\n     *\n     * Given n+1 control points for an n-th degree Bezier curve and\n     * a number t between 0 and 1, it will return two arrays, each\n     * with n+1 new control points. The returned control points define\n     * two Bezier curves that together form the original Bezier curve\n     * in two peaces, split at the t-th point.\n     *\n     * @author Balint Morvai <balint@morvai.de>\n     * @license http://en.wikipedia.org/wiki/MIT_License MIT License\n     */\n    var bsplit = function(points, t0) {\n        var n = points.length - 1; // number of control points\n        var b = [];       // coefficients as in De Casteljau's algorithm\n        var res1 = [];    // first curve resulting control points\n        var res2 = [];    // second curve resulting control points\n        var t1 = 1 - t0;\n\n        // multiply point with scalar factor\n        var pf = function(p, f) {\n            var res = [];\n            for(var i = 0; i < p.length; i++) {\n                res.push(f * p[i]);\n            }\n            return res;\n        };\n        // add points as vectors\n        var pp = function(p1, p2) {\n            var res = [];\n            for(var i = 0; i < Math.min(p1.length, p2.length); i++) {\n                res.push(p1[i] + p2[i]);\n            }\n            return res;\n        };\n\n        // set original coefficients: b[i][0] = points[i]\n        for(var i = 0; i <= n; i++) {\n            points[i] = (typeof points[i] == \"object\") ? points[i] : [points[i]];\n            b.push([ points[i] ]);\n        }\n        // get all coefficients\n        for(var j = 1; j <= n; j++) {\n            for(var i = 0; i <= (n-j); i++) {\n                b[i].push( pp(\n                        pf(b[i][j-1], t1),\n                        pf(b[i+1][j-1], t0)\n                ));\n            }\n        }\n        // set result: res1 & res2\n        for(var j = 0; j <= n; j++) {\n            res1.push(b[0][j]);\n            res2.push(b[j][n-j]);\n        }\n\n        return [res1, res2];\n    };\n\n    /**\n     * Shift given value randomly +/- by fuzzyness factor f / 2\n     * NOTE: not _really_ randomly but with alternating signs.\n     * Two times > 0, two times < 0, two times > 0, ... !\n     * NOTE: This relies on being called an even number of times\n     * from every context! (Which makes sense in a 2D space)\n     * @param val value to shift randomly\n     * @param f fuzzyness factor\n     * @return number\n     */\n    var fuzzDrunk = function(val, f) {\n        // get random sign\n        if(++fuzzDrunk.count > 2) {\n            fuzzDrunk.count = 0;\n            fuzzDrunk.sign *= -1;\n        }\n        return val + f * (rand() / 2 + fuzzDrunk.sign * 0.5);\n    }\n    fuzzDrunk.count = 0;\n    fuzzDrunk.sign = +(new Date()) % 2 ? 1 : -1; // random first sign\n\n    /**\n     * Shift given value randomly +/- by fuzzyness factor f / 2\n     * NOTE: not _really_ randomly, but with every 2nd call\n     * having a strong variation relative to the prior call.\n     * @param val value to shift randomly\n     * @param f fuzzyness factor\n     * @return number\n     */\n    var fuzzNormal = function(val, f) {\n        // get random number\n        var i = fuzzNormal.count;\n        var rnd = (rand() - 0.5);\n\n        if(++fuzzNormal.count == 2)\n            fuzzNormal.count = 0;\n\n        var res = val + f * (rnd - fuzzNormal.rnds[i]);\n        fuzzNormal.rnds[i] = rnd;\n\n        return res;\n    }\n    fuzzNormal.count = 0;\n    fuzzNormal.rnds = [0, 0];\n\n    /**\n     * Shift given value randomly +/- by fuzzyness factor f / 2\n     * @param val value to shift randomly\n     * @param f fuzzyness factor\n     * @return number\n     */\n    var fuzz = function(val, f) {\n        return C.drunk ? fuzzDrunk(val, f) : fuzzNormal(val, f);\n    }\n\n    /**\n     * Distance between 2 numbers in 2 dim space\n     * @param x0 1st point x\n     * @param y0 1st point y\n     * @param x1 2nd point x\n     * @param y1 2nd point y\n     * @return number\n     */\n    var dist2 = function(x0, y0, x1, y1) {\n        var dx = x1 - x0;\n        var dy = y1 - y0;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Test whether the given variable is an array.\n     * @param a var to test\n     * @return bool\n     */\n    var isArray = function(a) {\n        return Object.prototype.toString.call(a) === '[object Array]';\n    }\n\n    // ----------------------set drawing method-------------------------\n    // HTML5 Canvas context\n    if(libName == \"canvas\") {\n        path = function(x0, y0, cx, cy, x1, y1) {\n            this.moveTo(x0, y0);\n            this.quadraticCurveTo(cx, cy, x1, y1);\n            C.pathPos = { x:x1, y:y1 };\n        }\n        finish = function() {\n            this.stroke();\n            return this;\n        };\n        begin = function() {\n            this.beginPath();\n            return this;\n        };\n    }\n    else {\n        // for all svg libs let \"path\" & \"begin\" be as below\n        path = function(x0, y0, cx, cy, x1, y1) {\n            x0 = round(x0); y0 = round(y0); cx = round(cx);\n            cy = round(cy); x1 = round(x1); y1 = round(y1);\n            // \"move to\" only required if (x0, y0) != current pos AND as first path cmd\n            if(C.pathPos.x != x0 || C.pathPos.y != y0 || pathStr.length == 0) {\n                pathStr = pathStr + [\"M\", x0, y0, \"Q\", cx, cy, x1, y1].join(' ');\n            }\n            else {\n                pathStr = pathStr + [\"Q\", cx, cy, x1, y1].join(' ');\n            }\n            C.pathPos = { x:x1, y:y1 };\n            return this;\n        };\n        begin = function() {\n            pathStr = \"\";\n            C.pathPos = { x:0, y:0 };\n            return this;\n        };\n    }\n    // Raphael.js\n    if(libName == \"raphael\") {\n        finish = function() {\n            return this.path(pathStr);\n        };\n    }\n    // D3.js\n    if(libName == \"d3\") {\n        finish = function() {\n            return this.append(\"svg:path\").attr(\"d\", pathStr);\n        };\n    }\n    // SVG.js\n    if(libName == \"svg\") {\n        // draws path object from current pathStr on \"this\" & returns it\n        finish = function() {\n            return this.path(pathStr);\n        };\n    }\n}\nC.bindTo = bindTo;\n\n/**\n * @brief Round to the precision defined in local scope.\n *\n * @param {Float} x\n * @return {Float}\n */\nfunction round(x) {\n    return Math.round(x * roundFactor) / roundFactor;\n}\n\n/**\n * @brief Parse an svg path object and return commands\n * Parse an svg path object and generate an Array of path commands.\n * Each command is an Array of the form `[command, arg1, arg2, ...]`\n * NOTE: parsing is done via \"pathSegList\" which is faster and more\n * reliable than parsing the path string directly, but might not\n * work in old browsers.\n *\n * @author Balint Morvai <balint@morvai.de>\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\n * @param {Object} path object\n * @return {Array}\n */\nfunction parsePath(path) {\n    // some browser bugs can make pathSegList go missing - a workaround\n    if(! path.pathSegList) {\n        var newPath = document.createElementNS(\"http://www.w3.org/2000/svg\", 'path');\n        newPath.setAttribute('d', path.getAttribute('d'));\n    }\n    var list = path.pathSegList || newPath.pathSegList;\n    if(! list.length) list = list._list;\n    var res = [];\n    for(var i = 0; i < list.length; i++) {\n        var cmd = list[i].pathSegTypeAsLetter;\n        var sub = [];\n        switch(cmd) {\n            case \"C\":\n            case \"c\":\n                sub.unshift(list[i].y2); sub.unshift(list[i].x2);\n            case \"Q\":\n            case \"q\":\n                sub.unshift(list[i].y1); sub.unshift(list[i].x1);\n            case \"M\":\n            case \"m\":\n            case \"L\":\n            case \"l\":\n                sub.push(list[i].x); sub.push(list[i].y);\n                break;\n            case \"A\":\n            case \"a\":\n                sub.push(list[i].r1); sub.push(list[i].r2);\n                sub.push(list[i].angle);\n                sub.push(list[i].largeArcFlag);\n                sub.push(list[i].sweepFlag);\n                sub.push(list[i].x); sub.push(list[i].y);\n                break;\n            case \"H\":\n            case \"h\":\n                sub.push(list[i].x);\n                break;\n            case \"V\":\n            case \"v\":\n                sub.push(list[i].y);\n                break;\n            case \"S\":\n            case \"s\":\n                sub.push(list[i].x2); sub.push(list[i].y2);\n                sub.push(list[i].x); sub.push(list[i].y);\n                break;\n            case \"T\":\n            case \"t\":\n                sub.push(list[i].x); sub.push(list[i].y);\n                break;\n        }\n        sub.unshift(cmd);\n        res.push(sub);\n    }\n    return res;\n}\n\n// set options\nC.init({\n    fsteps: fsteps,\n    msteps: msteps,\n    ff: ff,\n    ffc: ffc,\n    drunk: drunk,\n    context: context\n});\n\n// Raphael.js\nif(typeof Raphael != \"undefined\") {\n    bindTo(\"raphael\",   // library name\n           Raphael.fn); // root object to hook in to\n}\n\n// SVG.js\nif(typeof SVG != \"undefined\") {\n    var dummy = {};\n    bindTo(\"svg\", dummy);\n    SVG.extend(SVG.Set, dummy);\n    SVG.extend(SVG.Group, dummy);\n    SVG.extend(SVG.Element, dummy);\n}\n\n// D3.js\nif(typeof d3 != \"undefined\") {\n    bindTo(\"d3\", d3.selection.prototype);\n    bindTo(\"d3\", d3.selection.enter.prototype);\n}\n\n// comic.js - bind to self\nbindTo(\"self\", COMIC);\n\n})();\n"],"names":[],"sourceRoot":""}